#!/usr/bin/env python
# -*- coding: ascii -*-

"""
Algorithm to mine disjunctive frequent itemsets

  This algorithm differs from the conjunctive itemset mining algorithms
  in the sense that it mines ORed itemsets instead of ANDed itemsets.

  The algorithm makes use of FPTree to store the dataset in a condensed form.

  Steps carried out by this algorithms are as follows:
  (Step 1)   Read the original dataset and create a new dataset with items
          mapped to a unique integer i.e. map each item to a unique integer ID.
          This step will be termed as preprocessing.

  (Step 2)   Scan the new dataset and calculate the frequency of each item present
          in the dataset.

  (Step 3)    We scan the dataset one more time to build an FPTree using the
          the frequencies of the items

  (Step 4)    We next traverse the itemset lattice in the top down order i.e.
          enumerating the lattice from items with higher cardinality to items
          with less cardinality.

  (Step 5)    For each such itemset, check if the itemset is a subset of any
          maximal infrequent itemset:
          - if NO: Use the FP Tree Property to find the support of the itemset.

  (Step 6)    If the itemset has support value greater than the min support
          threshold, then we add the itemset to the frequent itemset list,
          along with its support value.

  (Step 7)    Step 4 to 6 are repeated for all itemsets in the itemset lattice.
          The algorithm stops when all itemsets have been processed. The resultant
          list of frequent itemsets form the list of disjunctive frequent itemsets
          generated by our algorithm.

"""

import sys
from collections import defaultdict

__author__ = 'Nihal Jain (nihal.jain@iitg.ernet.in)'
__version__ = '0.2'
__date__ = '20160810'


class FPNode(object):
    """Blueprint of a node in the FPTree"""

    def __init__(self, tree, item, count=1):
        """Function to initialise all the attributes of a FPTree node"""
        self._tree = tree
        self._item = item
        self._count = count
        self._parent = None
        self._children = {}
        self._neighbour = None

    @property
    def tree(self):
        """Returns the tree in which this node is present"""
        return self._tree

    @property
    def item(self):
        """Returns the item represented by this node"""
        return self._item

    @property
    def count(self):
        """Returns the frequency of the item represented by this node"""
        return self._count

    @property
    def parent(self):
        """Returns the parent node of this node"""
        return self._parent

    @property
    def children(self):
        """Returns the nodes which are children of this node"""
        return tuple(self._children.items())

    @property
    def neighbour(self):
        """"Returns the node which is at the same depth and has the same node as parent and lies to the right of the
        tree. Both the nodes have the same """
        return self._neighbour

    @parent.setter
    def parent(self, parentNode):
        """Function to set the parent node of this node"""
        if parentNode is not None and not isinstance(parentNode, FPNode):
            raise TypeError("The parent node of a node must be a FPNode")
        if parentNode and parentNode.tree is not self.tree:
            raise ValueError("The parent node of a node must belong to the same tree")
        self._parent = parentNode

    @neighbour.setter
    def neighbour(self, neighbourNode):
        """Function to set the neighbour node of this node"""
        if neighbourNode is not None and not isinstance(neighbourNode, FPNode):
            raise TypeError("The neighbour node of a node must be a FPNode")
        if neighbourNode and neighbourNode.tree is not self.tree:
            raise ValueError("The neighbour node of a node must belong to the same tree")
        self._neighbour = neighbourNode

    @property
    def root(self):
        """Return True if this node is the root node of the tree, otherwise False"""
        return self._item is None and self._count is None

    @property
    def leaf(self):
        """Return True if this node is a leaf node, otherwise False"""
        return len(self._children) == 0

    def increment(self):
        """Function to increment the count of the item represented by this node"""
        if self._count is None:
            raise ValueError("No count value associated with the node")
        self._count += 1

    def searchChidren(self, item):
        """Check whether this node has a node representing item as a child.
        If yes, then return that node, otherwise return None"""
        try:
            return self._children[item]
        except KeyError:
            return None

    def add(self, childNode):
        """Function to add a node as child node of this node"""
        if childNode is not None and not isinstance(childNode, FPNode):
            raise TypeError("The child node of a node must be a FPNode")

        if not childNode.item in self._children:
            self._children[childNode.item] = childNode
            childNode.parent = self

    def __contains__(self, item):
        return item in self._children

    def inspect(self, depth=0):
        print(('  ' * depth) + repr(self))
        for child in self.children:
            child.inspect(depth + 1)

    def __repr__(self):
        if self.root:
            return "<%s (root)>" % type(self).__name__
        return "<%s %r (%r)>" % (type(self).__name__, self.item, self.count)


def processDataset(filePath, numeric):
    """Function to process the given dataset and generate a list of lists containing transactions and their
    corresponding items"""

    # create a list to store the transactions present in the dataset
    transactions = []

    # try to open the file and read its contents
    try:
        # fp is a file object used to operate on the file
        # we open the file in raed mode
        fp = open(filePath, "r")

        # reads the file until EOF using readline() and returns a list containing the lines
        # and stores it in variable dataset
        dataset = fp.readlines()

        # close the file after reading is complete
        fp.close()

    # raise exception and exit if there is any read error or if file is not found
    except IOError:
        print("ERROR: file not found or unable to read data")
        sys.exit(-1)

    # process each line in the dataset
    for line in dataset:
        # check if items are numerals
        if numeric:

            # create a list to store the items present in a transaction
            transaction = []

            # convert each item into an integer and append it to the transaction
            for item in line.split():
                transaction.append(int(item))

            # append the transaction to the list of transactions
            transactions.append(transaction)

        # if items are not numerals
        else:
            #  after splitting the line into a list of items, append the items list to the transaction list
            transactions.append(line.split())

    printTransactions(transactions)

    # return the list of lists containing the transactions
    return transactions


def printTransactions(transactions):
    """Function to print the transactions present in the list of lists containing the transactions"""
    for transaction in transactions:
        for item in transaction:
            print(str(item)+" ", end="", flush=True)
        print('.')


def filterTransactions(transactions, minSupp, includeSupp=False):
    """Function to filter out all items with support count less than minimum support. It returns a new list of
     transactions containing only the items satisfying the minimum support threshold. Each newly created transaction,
     within the list of transactions, stores items in a transaction ordered by frequency. Items with higher support
     value come first in the item list of the transaction."""

    # create a dictionary such that when a new key is encountered for the first time i.e. if it is already not there in
    # the mapping, a new entry is automatically created using the default_factory function which returns 0.
    itemsDict = defaultdict(lambda: 0)

    # count the frequency of each item and increment it by 1 whenever it is encountered in a transaction
    # a new key is created whenever an item is encountered for the first time, with its value set to 0
    for transaction in transactions:
        for item in transaction:
            itemsDict[item] += 1

    print(itemsDict)

    # create a new dictionary which contains only those items which have support count greater than or equal to minimum\
    # support threshold
    itemsDict = dict((item , support) for item, support in itemsDict.items()
                 if support >= minSupp)

    print(itemsDict)

    def cleanTransactions(transaction):
        """Function to filter a transaction such that only those items remain which satisfy the minimum support
        threshold and sort the items in a transaction based on their frequency, with items having higher support coming
        first"""
        # filter transaction and sustain only items which have an entry in the itemDict
        transaction = list(filter(lambda v: v in itemsDict, transaction))

        # sort the transaction containing a list of items in reverse order
        transaction.sort(key=lambda v: itemsDict[v], reverse=True)

        # return the new transaction
        return transaction

    # create a list to store the cleaned list of transactions
    transactionsNew =  []

    # map cleanTransactions function to each transaction present in the list of transactions
    # i.e. clean each transaction
    for transaction in map(cleanTransactions, transactions):
        transactionsNew.append(transaction)

    printTransactions(transactionsNew)

    # return the newly created cleaned list of transactions
    return transactionsNew


if __name__ == '__main__':
    # import the OptionParser module which will be used to parse the options passed as argument
    from optparse import OptionParser

    # initialise OptionParser object and pass a string which will be used to display usage
    opt = OptionParser(usage='%scriptName datasetPath')

    # add an option for minimum support initialisation
    opt.add_option('-s','--minimum-support', dest='minSupp', type='int', help='Minimum itemset support (default = 2)')

    # add an option to choose whether to use numbers to represent items
    opt.add_option('-n', '--numeric', dest='numeric', action='store_true', help='Convert the values in the dataset to '
                                                                                'numerals (default = false)')
    # set minimum support to 2, by default, if no option passed as  parameter
    opt.set_defaults(minSupp=2)

    # set numeric to false, by default, if no option passed as parameter
    opt.set_defaults(numeric=False)

    # parse the arguments passed to the program into options and args
    options, args = opt.parse_args()

    # check if number of args is at least 1,
    # if less display the error message
    if len(args) < 1:
        opt.error('ERROR: Must provide the path to a dataset file')


    print('-------------------------------------------------------------------')
    print('     Disjunctive Frequent Itemset Mining: DFS Based Algorithm')
    print('-------------------------------------------------------------------')
    print('Parameters are as follows....')
    print('Dataset File Path: ' + str(args[0]))
    print('Minimum Support Threshold: ' + str(options.minSupp))
    print('-------------------------------------------------------------------')

    # create a list to store the transactions present in the dataset
    transactions = []

    # process the dataset, and retrieve a list of lists containing a list of transactions and corresponding items
    transactions = processDataset(args[0], options.numeric)

    # create a list to store all the frequent itemsets
    result = []

    # process the list of transactions and generate a list of frequent itemsets
    filterTransactions(transactions, options.minSupp)